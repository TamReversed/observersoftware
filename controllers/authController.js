const bcrypt = require('bcrypt');
const DataService = require('../services/dataService');
const config = require('../config');
const webauthnService = require('../services/webauthnService');
const { getRpIDFromOrigin } = require('../services/webauthnService');

const usersService = new DataService(config.paths.usersFile);

async function login(req, res, next) {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password are required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const valid = await bcrypt.compare(password, user.password);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    req.session.userId = user.id;
    req.session.username = user.username;
    res.json({ success: true, username: user.username });
  } catch (error) {
    next(error);
  }
}

function logout(req, res) {
  req.session.destroy();
  res.json({ success: true });
}

function getStatus(req, res) {
  if (req.session && req.session.userId) {
    const user = usersService.findById(req.session.userId);
    res.json({ 
      authenticated: true, 
      username: req.session.username,
      hasPasskey: user && user.webauthnCredentials && user.webauthnCredentials.length > 0
    });
  } else {
    res.json({ authenticated: false });
  }
}

function getCsrfToken(req, res) {
  // Token is already generated by generateCsrfToken middleware
  res.json({ csrfToken: req.session.csrfToken || null });
}

// WebAuthn Registration - Start
async function startWebAuthnRegistration(req, res, next) {
  try {
    const { username } = req.body;

    if (!username) {
      return res.status(400).json({ error: 'Username is required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Ensure webauthnCredentials array exists
    if (!user.webauthnCredentials) {
      user.webauthnCredentials = [];
      // Update user to persist the empty array
      usersService.updateById(user.id, { webauthnCredentials: [] });
    }

    // Check if user already has a passkey (we only allow one per user)
    if (user.webauthnCredentials.length > 0) {
      return res.status(400).json({ error: 'User already has a passkey registered' });
    }

    const existingCredentials = user.webauthnCredentials;
    
    try {
      // Get origin from request (handle Railway proxy)
      const protocol = req.headers['x-forwarded-proto'] || (req.secure ? 'https' : 'http');
      const host = req.headers.host || req.get('host');
      const origin = `${protocol}://${host}`;
      const options = await webauthnService.generateRegistrationOptionsForUser(
        user.id,
        user.username,
        existingCredentials,
        origin
      );

      // Store challenge in session
      req.session.webauthnChallenge = options.challenge;
      req.session.webauthnUserId = user.id;
      req.session.webauthnType = 'registration';

      res.json(options);
    } catch (error) {
      console.error('Error in startWebAuthnRegistration:', error);
      console.error('Error stack:', error.stack);
      return res.status(500).json({ 
        error: 'Failed to generate registration options',
        details: error.message,
        stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined
      });
    }
  } catch (error) {
    console.error('Error in startWebAuthnRegistration:', error);
    next(error);
  }
}

// WebAuthn Registration - Finish
async function finishWebAuthnRegistration(req, res, next) {
  try {
    const { response } = req.body;

    if (!response) {
      return res.status(400).json({ error: 'Registration response is required' });
    }

    // Verify session state
    if (!req.session.webauthnChallenge || 
        !req.session.webauthnUserId || 
        req.session.webauthnType !== 'registration') {
      return res.status(400).json({ error: 'Invalid registration session' });
    }

    const userId = req.session.webauthnUserId;
    const user = usersService.findById(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Get origin from request (handle Railway proxy)
    const protocol = req.headers['x-forwarded-proto'] || (req.secure ? 'https' : 'http');
    const host = req.headers.host || req.get('host');
    const origin = `${protocol}://${host}`;
    
    // Get rpID from origin
    const rpID = getRpIDFromOrigin(origin);
    
    // Create options object with stored challenge
    const options = {
      challenge: req.session.webauthnChallenge,
      rpID: rpID,
      origin: origin
    };

    try {
      const verification = await webauthnService.verifyRegistration(options, response, origin);

      if (!verification.verified) {
        console.error('Registration verification failed');
        return res.status(400).json({ error: 'Registration verification failed' });
      }

    // Add credential to user
    const updatedCredentials = user.webauthnCredentials || [];
    updatedCredentials.push(verification.credential);

    usersService.updateById(userId, {
      webauthnCredentials: updatedCredentials
    });

      // Clear session
      delete req.session.webauthnChallenge;
      delete req.session.webauthnUserId;
      delete req.session.webauthnType;

      res.json({ success: true, message: 'Passkey registered successfully' });
    } catch (error) {
      console.error('Error in finishWebAuthnRegistration verification:', error);
      console.error('Error stack:', error.stack);
      return res.status(500).json({ 
        error: 'Registration verification failed',
        details: error.message,
        stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined
      });
    }
  } catch (error) {
    console.error('Error in finishWebAuthnRegistration:', error);
    next(error);
  }
}

// WebAuthn Authentication - Start
async function startWebAuthnLogin(req, res, next) {
  try {
    const { username } = req.body;

    if (!username) {
      return res.status(400).json({ error: 'Username is required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check if user has passkey
    if (!user.webauthnCredentials || user.webauthnCredentials.length === 0) {
      return res.status(400).json({ error: 'No passkey registered for this user' });
    }

    // Get origin from request (handle Railway proxy)
    const protocol = req.headers['x-forwarded-proto'] || (req.secure ? 'https' : 'http');
    const host = req.headers.host || req.get('host');
    const origin = `${protocol}://${host}`;
    const options = await webauthnService.generateAuthenticationOptionsForUser(
      user.id,
      user.webauthnCredentials,
      origin
    );

    // Store challenge and user info in session
    req.session.webauthnChallenge = options.challenge;
    req.session.webauthnUserId = user.id;
    req.session.webauthnType = 'authentication';

    res.json(options);
  } catch (error) {
    next(error);
  }
}

// WebAuthn Authentication - Finish
async function finishWebAuthnLogin(req, res, next) {
  try {
    const { response } = req.body;

    if (!response) {
      return res.status(400).json({ error: 'Authentication response is required' });
    }

    // Verify session state
    if (!req.session.webauthnChallenge || 
        !req.session.webauthnUserId || 
        req.session.webauthnType !== 'authentication') {
      return res.status(400).json({ error: 'Invalid authentication session' });
    }

    const userId = req.session.webauthnUserId;
    const user = usersService.findById(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Find the credential that matches the response
    // SimpleWebAuthn returns id as base64url string
    const credentialId = response.id;
    
    // Try to find credential by matching the base64url ID
    const credential = user.webauthnCredentials.find(
      cred => cred.id === credentialId
    );

    if (!credential) {
      console.error('Credential not found. Response ID:', credentialId);
      console.error('Available credentials:', user.webauthnCredentials.map(c => c.id));
      return res.status(400).json({ error: 'Credential not found. Please register a new passkey.' });
    }

    // Get origin from request (handle Railway proxy)
    const protocol = req.headers['x-forwarded-proto'] || (req.secure ? 'https' : 'http');
    const host = req.headers.host || req.get('host');
    const origin = `${protocol}://${host}`;
    
    // Create options object with stored challenge
    const options = {
      challenge: req.session.webauthnChallenge,
      rpID: config.webauthn.rpID,
      origin: origin
    };

    const verification = await webauthnService.verifyAuthentication(
      options,
      response,
      credential,
      origin
    );

    if (!verification.verified) {
      return res.status(401).json({ error: 'Authentication verification failed' });
    }

    // Update credential counter (replay attack prevention)
    const credentialIndex = user.webauthnCredentials.findIndex(
      cred => cred.id === credentialId
    );
    if (credentialIndex !== -1) {
      user.webauthnCredentials[credentialIndex].counter = verification.newCounter;
      usersService.updateById(userId, {
        webauthnCredentials: user.webauthnCredentials
      });
    }

    // Create session
    req.session.userId = user.id;
    req.session.username = user.username;

    // Clear WebAuthn session
    delete req.session.webauthnChallenge;
    delete req.session.webauthnUserId;
    delete req.session.webauthnType;

    res.json({ success: true, username: user.username });
  } catch (error) {
    next(error);
  }
}

module.exports = {
  login,
  logout,
  getStatus,
  getCsrfToken,
  startWebAuthnRegistration,
  finishWebAuthnRegistration,
  startWebAuthnLogin,
  finishWebAuthnLogin
};




