const bcrypt = require('bcrypt');
const DataService = require('../services/dataService');
const config = require('../config');
const webauthnService = require('../services/webauthnService');

const usersService = new DataService(config.paths.usersFile);

async function login(req, res, next) {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password are required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const valid = await bcrypt.compare(password, user.password);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    req.session.userId = user.id;
    req.session.username = user.username;
    res.json({ success: true, username: user.username });
  } catch (error) {
    next(error);
  }
}

function logout(req, res) {
  req.session.destroy();
  res.json({ success: true });
}

function getStatus(req, res) {
  if (req.session && req.session.userId) {
    const user = usersService.findById(req.session.userId);
    res.json({ 
      authenticated: true, 
      username: req.session.username,
      hasPasskey: user && user.webauthnCredentials && user.webauthnCredentials.length > 0
    });
  } else {
    res.json({ authenticated: false });
  }
}

function getCsrfToken(req, res) {
  // Token is already generated by generateCsrfToken middleware
  res.json({ csrfToken: req.session.csrfToken || null });
}

// WebAuthn Registration - Start
async function startWebAuthnRegistration(req, res, next) {
  try {
    const { username } = req.body;

    if (!username) {
      return res.status(400).json({ error: 'Username is required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if user already has a passkey (we only allow one per user)
    if (user.webauthnCredentials && user.webauthnCredentials.length > 0) {
      return res.status(400).json({ error: 'User already has a passkey registered' });
    }

    const existingCredentials = user.webauthnCredentials || [];
    const options = await webauthnService.generateRegistrationOptionsForUser(
      user.id,
      user.username,
      existingCredentials
    );

    // Store challenge in session
    req.session.webauthnChallenge = options.challenge;
    req.session.webauthnUserId = user.id;
    req.session.webauthnType = 'registration';

    res.json(options);
  } catch (error) {
    next(error);
  }
}

// WebAuthn Registration - Finish
async function finishWebAuthnRegistration(req, res, next) {
  try {
    const { response } = req.body;

    if (!response) {
      return res.status(400).json({ error: 'Registration response is required' });
    }

    // Verify session state
    if (!req.session.webauthnChallenge || 
        !req.session.webauthnUserId || 
        req.session.webauthnType !== 'registration') {
      return res.status(400).json({ error: 'Invalid registration session' });
    }

    const userId = req.session.webauthnUserId;
    const user = usersService.findById(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Create options object with stored challenge
    const options = {
      challenge: req.session.webauthnChallenge,
      rpID: config.webauthn.rpID,
      origin: config.webauthn.origin
    };

    const verification = await webauthnService.verifyRegistration(options, response);

    if (!verification.verified) {
      return res.status(400).json({ error: 'Registration verification failed' });
    }

    // Add credential to user
    const updatedCredentials = user.webauthnCredentials || [];
    updatedCredentials.push(verification.credential);

    usersService.updateById(userId, {
      webauthnCredentials: updatedCredentials
    });

    // Clear session
    delete req.session.webauthnChallenge;
    delete req.session.webauthnUserId;
    delete req.session.webauthnType;

    res.json({ success: true, message: 'Passkey registered successfully' });
  } catch (error) {
    next(error);
  }
}

// WebAuthn Authentication - Start
async function startWebAuthnLogin(req, res, next) {
  try {
    const { username } = req.body;

    if (!username) {
      return res.status(400).json({ error: 'Username is required' });
    }

    const users = usersService.findAll();
    const user = users.find(u => u.username === username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check if user has passkey
    if (!user.webauthnCredentials || user.webauthnCredentials.length === 0) {
      return res.status(400).json({ error: 'No passkey registered for this user' });
    }

    const options = await webauthnService.generateAuthenticationOptionsForUser(
      user.id,
      user.webauthnCredentials
    );

    // Store challenge and user info in session
    req.session.webauthnChallenge = options.challenge;
    req.session.webauthnUserId = user.id;
    req.session.webauthnType = 'authentication';

    res.json(options);
  } catch (error) {
    next(error);
  }
}

// WebAuthn Authentication - Finish
async function finishWebAuthnLogin(req, res, next) {
  try {
    const { response } = req.body;

    if (!response) {
      return res.status(400).json({ error: 'Authentication response is required' });
    }

    // Verify session state
    if (!req.session.webauthnChallenge || 
        !req.session.webauthnUserId || 
        req.session.webauthnType !== 'authentication') {
      return res.status(400).json({ error: 'Invalid authentication session' });
    }

    const userId = req.session.webauthnUserId;
    const user = usersService.findById(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Find the credential that matches the response
    const credentialId = response.id;
    const credential = user.webauthnCredentials.find(
      cred => cred.id === credentialId
    );

    if (!credential) {
      return res.status(400).json({ error: 'Credential not found' });
    }

    // Create options object with stored challenge
    const options = {
      challenge: req.session.webauthnChallenge,
      rpID: config.webauthn.rpID,
      origin: config.webauthn.origin
    };

    const verification = await webauthnService.verifyAuthentication(
      options,
      response,
      credential
    );

    if (!verification.verified) {
      return res.status(401).json({ error: 'Authentication verification failed' });
    }

    // Update credential counter (replay attack prevention)
    const credentialIndex = user.webauthnCredentials.findIndex(
      cred => cred.id === credentialId
    );
    if (credentialIndex !== -1) {
      user.webauthnCredentials[credentialIndex].counter = verification.newCounter;
      usersService.updateById(userId, {
        webauthnCredentials: user.webauthnCredentials
      });
    }

    // Create session
    req.session.userId = user.id;
    req.session.username = user.username;

    // Clear WebAuthn session
    delete req.session.webauthnChallenge;
    delete req.session.webauthnUserId;
    delete req.session.webauthnType;

    res.json({ success: true, username: user.username });
  } catch (error) {
    next(error);
  }
}

module.exports = {
  login,
  logout,
  getStatus,
  getCsrfToken,
  startWebAuthnRegistration,
  finishWebAuthnRegistration,
  startWebAuthnLogin,
  finishWebAuthnLogin
};




